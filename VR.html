<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Simple A-Frame VR+AR Demo (Hands + Joystick Move)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- A-Frame -->
  <script src="https://unpkg.com/aframe@1.4.2/dist/aframe.min.js"></script>

  <!-- Small helper: aframe-extras movement-controls would normally be used,
       but to keep dependencies minimal we implement a compact thumbstick component below. -->
  <style>
    /* Basic overlay controls (removable) */
    .ui {
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 9999;
      display:flex;
      gap:8px;
    }
    .ui button {
      padding:8px 12px;
      border: none;
      background: rgba(0,0,0,0.6);
      color: white;
      font: 14px system-ui;
      border-radius:6px;
      cursor:pointer;
    }
  </style>
</head>
<body>
  <div class="ui" id="controls">
    <!-- A-Frame will add its own Enter VR button (but it's hidden in some contexts).
         We add an explicit VR button to ensure it's present and to respect vr-mode-ui attribute. -->
    <button id="enterVR">Enter VR</button>
    <button id="enterAR">Enter AR</button>
    <!-- Optional: quick recenter -->
    <button id="recenter">Recenter</button>
  </div>

  <a-scene background="color: #202330" vr-mode-ui="enabled: true" embedded>
    <!-- Camera rig that moves with joystick -->
    <a-entity id="rig" position="0 1.6 0">
      <a-entity id="camera" camera look-controls wasd-controls-enabled="false"></a-entity>

      <!-- Left & Right hands (opens native hand models where supported) -->
      <a-entity id="left-hand"
                hand-controls="hand: left; handModelStyle: lowPoly; color: #ffcccc"
                vive-controls="hand: left; model: true"
                oculus-touch-controls="hand: left"
                windows-motion-controls="hand: left"
                raycaster="objects: .interactable"
                line="opacity: 0.75">
      </a-entity>

      <a-entity id="right-hand"
                hand-controls="hand: right; handModelStyle: lowPoly; color: #ccffcc"
                vive-controls="hand: right; model: true"
                oculus-touch-controls="hand: right"
                windows-motion-controls="hand: right"
                raycaster="objects: .interactable"
                line="opacity: 0.75">
      </a-entity>
    </a-entity>

    <!-- Floor and simple scene objects -->
    <a-plane rotation="-90 0 0" width="40" height="40" color="#101216"></a-plane>

    <a-entity position="0 0 -3">
      <a-box position="-1 0.5 0" depth="0.5" height="1" width="1" color="#4CC3D9" class="interactable"></a-box>
      <a-box position="1 0.5 0" depth="0.5" height="1" width="1" color="#EF2D5E" class="interactable"></a-box>
      <a-sphere position="0 0.8 0.7" radius="0.4" color="#FFC65D" class="interactable"></a-sphere>
      <a-text value="Use joystick to move. Use hands to point." position="0 1.6 -0.2" align="center"></a-text>
    </a-entity>

    <!-- Lighting -->
    <a-entity light="type: ambient; intensity: 0.6"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="0 4 2"></a-entity>

    <!-- Optional 3D in-scene menu (commented out). If you want a menu, uncomment and customize --
         it's a 3D object in the world, not a 2D overlay.
    <a-entity id="3d-menu" position="0 1.2 -1.2" visible="false">
      <a-plane width="0.8" height="0.5" color="#111" opacity="0.9"></a-plane>
      <a-text value="3D Menu\nOption A\nOption B" align="center" position="0 0 0.01"></a-text>
    </a-entity>
    -->

    <!-- Thumbstick movement component -->
    <script>
      AFRAME.registerComponent('thumbstick-movement', {
        schema: {
          speed: {type: 'number', default: 1.8},   // meters per second
          smooth: {type: 'boolean', default: true},
          deadzone: {type: 'number', default: 0.2}
        },
        init: function () {
          this.direction = new THREE.Vector3();
          this.tempVec = new THREE.Vector3();
          this.anchor = this.el; // rig entity
          this.vrDisplay = null;
        },
        tick: function (time, delta) {
          const dt = delta / 1000;
          const gp = navigator.getGamepads ? navigator.getGamepads() : [];
          if (!gp) { return; }

          // find first gamepad with axes (common approach) that is likely a controller
          let axes = null;
          for (let i=0;i<gp.length;i++){
            const g = gp[i];
            if (!g || !g.connected || !g.axes) continue;
            // prefer gamepads with "xr" mapping or typical controller ids
            if (g.id && /oculus|vive|index|xr|quest|hand/.test(g.id.toLowerCase())) {
              axes = g.axes;
              break;
            }
            // fallback: any gamepad with >=2 axes
            if (g.axes.length >= 2 && !axes) axes = g.axes;
          }
          if (!axes) return;

          // common thumbstick mapping uses axes[2],axes[3] for secondary stick, axes[0],axes[1] for primary.
          // We'll search for the first non-zero pair to use.
          let x = 0, y = 0;
          const pairs = [[0,1],[2,3],[4,5]];
          for (let p of pairs){
            const ax = axes[p[0]] || 0;
            const ay = axes[p[1]] || 0;
            if (Math.abs(ax) > this.data.deadzone || Math.abs(ay) > this.data.deadzone) {
              x = ax; y = ay; break;
            }
            // if none exceed deadzone but small movement exists, still allow it:
            if (!pairs.some(pp => Math.abs(axes[pp[0]]||0) > this.data.deadzone || Math.abs(axes[pp[1]]||0) > this.data.deadzone)) {
              x = axes[0]||0; y = axes[1]||0;
            }
          }

          // If still near zero, skip
          if (Math.abs(x) < this.data.deadzone && Math.abs(y) < this.data.deadzone) return;

          // Move in the direction the camera is facing (on XZ plane)
          const camera = this.el.querySelector('[camera]') || document.querySelector('a-camera, [camera]');
          if (!camera) return;

          // Get camera world rotation yaw
          const camObj = camera.object3D;
          const rigObj = this.el.object3D;
          const euler = new THREE.Euler().setFromQuaternion(camObj.quaternion, 'YXZ');
          const yaw = euler.y;

          // Forward vector from yaw
          this.direction.set(0,0,-1);
          this.direction.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
          // Right vector
          this.tempVec.copy(this.direction).applyAxisAngle(new THREE.Vector3(0,1,0), Math.PI/2);

          // x is left/right, y is forward/back (gamepad often -1 up, +1 down)
          const forward = -y; // invert so forward thumbstick pushes you forward
          const strafe = x;

          const moveVec = new THREE.Vector3();
          moveVec.addScaledVector(this.direction, forward);
          moveVec.addScaledVector(this.tempVec, strafe);

          if (moveVec.length() > 0.0001) {
            moveVec.normalize();
            moveVec.multiplyScalar(this.data.speed * dt);
            if (this.data.smooth) {
              rigObj.position.x += moveVec.x;
              rigObj.position.z += moveVec.z;
            } else {
              rigObj.position.add(moveVec);
            }
          }
        }
      });

      // Attach to rig on scene load
      document.addEventListener('DOMContentLoaded', function () {
        const rig = document.querySelector('#rig');
        rig.setAttribute('thumbstick-movement', '');
      });
    </script>

    <!-- Minimal helper to show enter AR / VR functionality -->
    <script>
      // Hook up UI buttons:
      document.addEventListener('DOMContentLoaded', async () => {
        const enterVR = document.getElementById('enterVR');
        const enterAR = document.getElementById('enterAR');
        const recenter = document.getElementById('recenter');

        // Tie Enter VR to A-Frame's default requestPresent (works across devices)
        enterVR.addEventListener('click', function () {
          const scene = document.querySelector('a-scene');
          if (scene && scene.is('vr-mode')) {
            scene.exitVR();
            return;
          }
          // A-Frame handles entering VR via its internal button; programmatic request:
          const canvas = scene.renderer && scene.renderer.domElement;
          if (navigator.xr && navigator.xr.requestSession) {
            // try to request 'immersive-vr' session via WebXR (A-Frame will manage if present)
            navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
              if (supported) {
                scene.enterVR();
              } else {
                // fallback to A-Frame's enter (works in many cases)
                scene.enterVR();
              }
            }).catch(()=> scene.enterVR());
          } else {
            scene.enterVR();
          }
        });

        // Try to start a WebXR immersive-ar session; will fail gracefully if unsupported.
        enterAR.addEventListener('click', async function () {
          if (!navigator.xr || !navigator.xr.isSessionSupported) {
            alert('WebXR not available in this browser for AR.');
            return;
          }
          const supported = await navigator.xr.isSessionSupported('immersive-ar').catch(()=>false);
          if (!supported) {
            alert('Device/browser does not support immersive AR.');
            return;
          }
          try {
            // Request AR session with DOM overlay so page UI remains visible where supported.
            const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['local-floor', 'bounded-floor'], optionalFeatures: ['dom-overlay'], domOverlay: { root: document.body } });
            // A-Frame's renderer cannot take an external session easily in older versions; simplest: let A-Frame handle if it supports AR.
            // Here we create a temporary A-Frame scene request to enter AR
            const scene = document.querySelector('a-scene');
            if (scene && scene.renderer && scene.renderer.xr) {
              await scene.renderer.xr.setSession(session);
              scene.enterVR(); // A-Frame uses "VR" mode but with AR session it becomes AR display
            } else {
              alert('AR session started, but scene couldn\'t attach it. Try running this page in a headset browser or a WebXR-enabled Chrome/Edge.');
            }
          } catch (err) {
            console.warn('AR request failed:', err);
            alert('AR session request failed.');
          }
        });

        recenter.addEventListener('click', function () {
          const rig = document.querySelector('#rig');
          if (rig) {
            rig.setAttribute('position', '0 1.6 0');
          }
        });
      });
    </script>
  </a-scene>
</body>
</html>
