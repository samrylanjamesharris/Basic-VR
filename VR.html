<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simple WebXR Hands - Grab & Toss</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    #info{position:fixed;left:12px;top:12px;max-width:420px;background:rgba(0,0,0,0.45);backdrop-filter:blur(4px);padding:10px;border-radius:8px;font-size:13px}
    #enterVR{position:fixed;right:12px;top:12px}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="info">
    <strong>Simple WebXR hands â€” Grab & Toss</strong>
    <p>Put on a WebXR-capable headset (Quest, Vision Pro, etc.). Use hand-tracking or controllers: pinch (thumb+index) to grab, release to toss. Press <em>Enter VR</em> to start.</p>
    <ul>
      <li>Grab cubes that float in front of you.</li>
      <li>Score increases per thrown cube that hits the floor.</li>
    </ul>
    <p>If your browser or headset doesn't support WebXR you will still see a 3D preview and an error in the console.</p>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { VRButton } from 'https://unpkg.com/three@0.152.2/examples/jsm/webxr/VRButton.js';
    import { XRHandModelFactory } from 'https://unpkg.com/three@0.152.2/examples/jsm/webxr/XRHandModelFactory.js';

    let camera, scene, renderer;
    let score = 0;
    const grabState = new Map(); // inputSource -> {object, offset}

    init();
    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x101218);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 50);
      camera.position.set(0,1.6,3);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      document.body.appendChild(VRButton.createButton(renderer));

      // Lights
      scene.add(new THREE.HemisphereLight(0x8080ff, 0x202020, 0.8));
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(5,10,2);
      scene.add(dir);

      // Floor
      const floorGeo = new THREE.PlaneGeometry(20,20);
      const floorMat = new THREE.MeshStandardMaterial({color:0x222244, metalness:0.1, roughness:0.9});
      const floor = new THREE.Mesh(floorGeo,floorMat);
      floor.rotation.x = -Math.PI/2;
      floor.position.y = 0;
      scene.add(floor);

      // Target area
      const grid = new THREE.GridHelper(20,20,0x444488,0x101014);
      grid.position.y = 0.001;
      scene.add(grid);

      // Floating cubes (interactables)
      const boxGeo = new THREE.BoxGeometry(0.18,0.18,0.18);
      for(let i=0;i<12;i++){
        const mat = new THREE.MeshStandardMaterial({color:new THREE.Color().setHSL(Math.random(),0.7,0.5)});
        const cube = new THREE.Mesh(boxGeo, mat);
        cube.position.set((Math.random()-0.5)*2, 1 + Math.random()*0.8, -1 - Math.random()*1.2);
        cube.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.01, (Math.random()-0.5)*0.01, (Math.random()-0.5)*0.01);
        scene.add(cube);
      }

      // Controllers (for non-hand fallback and grips)
      const controller1 = renderer.xr.getController(0);
      controller1.addEventListener('selectstart', onSelectStart);
      controller1.addEventListener('selectend', onSelectEnd);
      scene.add(controller1);

      const controller2 = renderer.xr.getController(1);
      controller2.addEventListener('selectstart', onSelectStart);
      controller2.addEventListener('selectend', onSelectEnd);
      scene.add(controller2);

      // Hand models + hand joint placeholders
      const handModelFactory = new XRHandModelFactory();
      for (let i = 0; i <= 1; i++) {
        const hand = renderer.xr.getHand(i);
        const model = handModelFactory.createHandModel(hand, 'mesh');
        hand.add(model);
        scene.add(hand);
      }

      window.addEventListener('resize', onWindowResize);
      renderer.setAnimationLoop(animate);
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onSelectStart(ev){
      // controller select acts like grab: raycast and attach first intersected cube
      const controller = ev.target;
      const tempMatrix = new THREE.Matrix4();
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      const rayOrigin = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
      const rayDir = new THREE.Vector3(0,0,-1).applyMatrix4(tempMatrix).normalize();

      const raycaster = new THREE.Raycaster(rayOrigin, rayDir, 0, 2);
      const intersects = raycaster.intersectObjects(scene.children, false).filter(i=>i.object.geometry && i.object.geometry.type==='BoxGeometry');
      if(intersects.length>0){
        const picked = intersects[0].object;
        grabState.set(controller, {object:picked});
      }
    }

    function onSelectEnd(ev){
      const controller = ev.target;
      const state = grabState.get(controller);
      if(state && state.object){
        // give a toss impulse based on controller movement (approx)
        state.object.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.02, 0.05, (Math.random()-0.5)*0.02);
        grabState.delete(controller);
      }
    }

    // utility to detect pinch: distance between thumb-tip and index-finger-tip joints
    function isPinching(hand){
      try{
        const thumb = hand.joints["thumb-tip"] || hand.joints[0x104];
        const index = hand.joints["index-finger-tip"] || hand.joints[0x10A];
        if(!thumb || !index) return false;
        const tPos = new THREE.Vector3();
        const iPos = new THREE.Vector3();
        thumb.getWorldPosition(tPos);
        index.getWorldPosition(iPos);
        return tPos.distanceTo(iPos) < 0.04; // 4cm threshold
      }catch(e){
        return false;
      }
    }

    function animate(){
      // simple physics for cubes
      scene.traverse(obj=>{
        if(obj.geometry && obj.geometry.type==='BoxGeometry'){
          // if grabbed by a hand/controller, skip physics
          let grabbed = false;
          for(const [k,v] of grabState.entries()){
            if(v.object===obj) grabbed=true;
          }
          if(!grabbed){
            // integrate
            obj.position.add(obj.userData.velocity);
            obj.userData.velocity.y -= 0.0015; // gravity
            // floor collision
            if(obj.position.y <= 0.09){
              obj.position.y = 0.09;
              obj.userData.velocity.set(0,0,0);
            }
            // damp
            obj.userData.velocity.multiplyScalar(0.995);
          }
        }
      });

      // handle hands: detect pinch and attach/detach objects
      for(let i=0;i<2;i++){
        const hand = renderer.xr.getHand(i);
        if(!hand) continue;
        const inPinch = isPinching(hand);
        const controllerKey = hand; // use hand object as key
        if(inPinch && !grabState.has(controllerKey)){
          // try to pick nearest cube within reach
          const palmPos = new THREE.Vector3();
          hand.getWorldPosition(palmPos);
          let nearest=null; let nd=Infinity;
          scene.traverse(obj=>{
            if(obj.geometry && obj.geometry.type==='BoxGeometry'){
              const d = obj.position.distanceTo(palmPos);
              if(d<0.25 && d<nd){ nd=d; nearest=obj; }
            }
          });
          if(nearest){ grabState.set(controllerKey, {object:nearest}); }
        }
        if(!inPinch && grabState.has(controllerKey)){
          // release and apply a toss
          const state = grabState.get(controllerKey);
          state.object.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.02, 0.06, (Math.random()-0.5)*0.02);
          grabState.delete(controllerKey);
        }
        // if holding, move object to hand
        if(grabState.has(controllerKey)){
          const state = grabState.get(controllerKey);
          const target = new THREE.Vector3();
          hand.getWorldPosition(target);
          // smooth follow
          state.object.position.lerp(target, 0.35);
          state.object.userData.velocity.set(0,0,0);
        }
      }

      renderer.render(scene, camera);
    }

  </script>
</body>
</html>
